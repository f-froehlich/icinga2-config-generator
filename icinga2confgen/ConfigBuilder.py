#!/usr/bin/python3
# -*- coding: utf-8

#  Icinga2 configuration generator
#
#  Icinga2 configuration file generator for hosts, commands, checks, ... in python
#
#  Copyright (c) 2020 Fabian Fröhlich <mail@icinga2.confgen.org> https://icinga2.confgen.org
#
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#  For all license terms see README.md and LICENSE Files in root directory of this Project.
import os
import shutil
from sha256 import sha256
from pathlib import Path

from tqdm import tqdm

from icinga2confgen.ValueChecker import ValueChecker


class ConfigBuilder:
    __servers = []
    __checks = []
    __templates = []
    __commands = []
    __notification_commands = []
    __hostgroups = []
    __servicegroups = []
    __usergroups = []
    __ssh_templates = []
    __time_periods = []
    __notification_templates = []
    __notifications = []
    __users = []
    __downtimes = []
    __zones = []
    __os = []
    __dependencies = []
    __package_manager = []
    __pbar = tqdm(desc="Configuring", unit=' Configs')
    __check_for_existence = True
    __utils = []

    @staticmethod
    def set_check_for_existence(enabled: bool):
        ConfigBuilder.__check_for_existence = enabled

    @staticmethod
    def replace_prefixes(string: str) -> str:

        for prefix in ValueChecker.get_prefixes():
            if string.startswith(prefix + '_'):
                return string.replace(prefix + '_', '', 1)
        return string

    @staticmethod
    def apply_utils():
        for util_class in ConfigBuilder.__utils:
            if util_class.is_auto_apply() and not util_class.is_auto_applied():
                util_class.apply()
                util_class.set_auto_applied(True)

    @staticmethod
    def __file_header() -> str:
        return """/*
 *  Icinga2 configuration generator
 *
 *  Icinga2 configuration file generator for hosts, commands, checks, ... in python
 *
 *  Copyright (c) 2020 Fabian Fröhlich <mail@icinga2.confgen.org> https://icinga2.confgen.org
 *
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 *  For all license terms see README.md and LICENSE Files in root directory of this Project.
 */



/************************************************************************************************
 *                                                                                              *
 *                                            ! ! !                                             *
 *                                       IMPORTANT NOTICE                                       *
 *                                            ! ! !                                             *
 *                                                                                              *
 *                                                                                              *
 *                                    DO NOT EDIT THIS FILE!                                    *
 *           This file is automatically generated with icinga2confgen python library.           *
 *                                                                                              *
 *                                                                                              *
 *                 Copyright (c) 2020 Fabian Fröhlich <mail@icinga2.confgen.org>                *
 *                                 https://icinga2.confgen.org                                  *
 *                                                                                              *
 ************************************************************************************************/



"""

    @staticmethod
    def __legacy_file_header() -> str:
        return ConfigBuilder.__file_header() + """/*



/************************************************************************************************
 *                                                                                              *
 *                                            ! ! !                                             *
 *                                       IMPORTANT NOTICE                                       *
 *                                            ! ! !                                             *
 *                                                                                              *
 *                                                                                              *
 *                                    THIS IS A LEGACY FILE!                                    *
 *             The usage of legacy files are only allowed for migration purposes and            *
 *              configurations for your own closed-source applications, as long as              *
 *               there is no interest from third parties for the configuration or               *
 *             underlining checks. If the check itself is open-source or there is an            *
 *             interest of third parties, then you have to publish the check command            *
 *                 and check configuration file as python code in this repository.              *
 *                                                                                              *
 *                                                                                              *
 *                 Copyright (c) 2020 Fabian Fröhlich <mail@icinga2.confgen.org>                *
 *                                 https://icinga2.confgen.org                                  *
 *                                                                                              *
 ************************************************************************************************/



"""

    @staticmethod
    def get_config(pretty: bool = False, master_zone='master'):
        ConfigBuilder.apply_utils()
        ConfigBuilder.__pbar.close()

        shutil.rmtree('zones.d', ignore_errors=True)

        global_configs = [
            {'dir': 'templates', 'config': ConfigBuilder.__templates},
            {'dir': 'commands', 'config': ConfigBuilder.__commands},
            {'dir': 'groups/servicegroups', 'config': ConfigBuilder.__servicegroups},
            {'dir': 'groups/hostgroups', 'config': ConfigBuilder.__hostgroups},
            {'dir': '../' + master_zone + '/groups/usergroups', 'config': ConfigBuilder.__usergroups},
            {'dir': '../' + master_zone + '/users', 'config': ConfigBuilder.__users},
            {'dir': 'ssh_templates', 'config': ConfigBuilder.__ssh_templates},
            {'dir': 'time_periods', 'config': ConfigBuilder.__time_periods},
            {'dir': '../' + master_zone + '/notifications/templates', 'config': ConfigBuilder.__notification_templates},
            {'dir': '../' + master_zone + '/notifications/notifications', 'config': ConfigBuilder.__notifications},
            {'dir': '../' + master_zone + '/notifications/commands', 'config': ConfigBuilder.__notification_commands},
            {'dir': 'downtimes', 'config': ConfigBuilder.__downtimes},
            {'dir': 'os', 'config': ConfigBuilder.__os},
            {'dir': 'package_manager', 'config': ConfigBuilder.__package_manager},
        ]

        total = len(ConfigBuilder.__servers) + len(ConfigBuilder.__dependencies) + len(ConfigBuilder.__checks)
        for config in global_configs:
            total += len(config['config'])

        pbar = tqdm(total=total, desc="Writing config", unit=' Configs')

        for config in global_configs:
            dirpath = "zones.d/global-templates/" + config['dir']
            for conf in config['config']:
                Path(dirpath).mkdir(parents=True, exist_ok=True)
                if pretty:
                    name = ConfigBuilder.replace_prefixes(conf['id'])
                else:
                    name = sha256(ConfigBuilder.replace_prefixes(conf['id']).encode('utf-8')).hexdigest()

                with open(dirpath + '/' + name + '.conf', "w",
                          encoding='utf-8') as file:
                    file.write(ConfigBuilder.__file_header() + conf['instance'].get_config().replace('  ', ''))
                pbar.update(1)

        server_instances = ConfigBuilder.get_instance('server')
        for conf in ConfigBuilder.__checks:
            if conf['instance'].is_generated():
                dirpath = "zones.d/" + conf['instance'].get_zone().get_id() + "/checks"
            else:
                servers_with_check = []
                for server in server_instances:
                    if conf['instance'] in server.get_all_checks():
                        servers_with_check.append(server)
                if 1 == len(servers_with_check):
                    dirpath = "zones.d/" + servers_with_check[0].get_zone().get_id() + "/checks"
                else:
                    dirpath = "zones.d/global-templates/checks"

            Path(dirpath).mkdir(parents=True, exist_ok=True)
            if pretty:
                name = ConfigBuilder.replace_prefixes(conf['id'])
            else:
                name = sha256(ConfigBuilder.replace_prefixes(conf['id']).encode('utf-8')).hexdigest()

            with open(dirpath + '/' + name + '.conf', "w",
                      encoding='utf-8') as file:
                file.write(ConfigBuilder.__file_header() + conf['instance'].get_config().replace('  ', ''))
            pbar.update(1)

        for conf in ConfigBuilder.__servers:
            server = conf['instance']
            zone = server.get_zone()
            dirpath = 'zones.d/' + ConfigBuilder.replace_prefixes(zone.get_id()) + '/'

            if pretty:
                name = ConfigBuilder.replace_prefixes(conf['id'])
            else:
                name = sha256(ConfigBuilder.replace_prefixes(conf['id']).encode('utf-8')).hexdigest()

            Path(dirpath).mkdir(parents=True, exist_ok=True)
            with open(dirpath + '/' + name + '.conf', "w",
                      encoding='utf-8') as file:
                file.write(ConfigBuilder.__file_header() + server.get_config().replace('  ', ''))
            pbar.update(1)

        for conf in ConfigBuilder.__dependencies:
            dependency = conf['instance']
            server = dependency.get_server()
            zone = server.get_zone()
            dirpath = 'zones.d/' + ConfigBuilder.replace_prefixes(zone.get_id()) + '/dependencies/'

            if pretty:
                name = ConfigBuilder.replace_prefixes(conf['id'])
            else:
                name = sha256(ConfigBuilder.replace_prefixes(conf['id']).encode('utf-8')).hexdigest()

            Path(dirpath).mkdir(parents=True, exist_ok=True)
            with open(dirpath + '/' + name + '.conf', "w",
                      encoding='utf-8') as file:
                file.write(ConfigBuilder.__file_header() + dependency.get_config().replace('  ', ''))
            pbar.update(1)
        pbar.close()

        pbar = tqdm(desc="Writing custom config", unit=' Configs')
        for custom_file in ConfigBuilder.__get_custom_files():
            content = ConfigBuilder.__read_custom_file(str(custom_file))

            file_name = os.path.basename(str(custom_file))
            extension = os.path.splitext(file_name)[1]
            new_file_dir = str(custom_file).replace('legacy-config.d', 'zones.d').replace(file_name, 'legacy-config.d/')

            if pretty:
                name = file_name
            else:
                name = sha256((str(custom_file) + content).encode('utf-8')).hexdigest() + extension

            new_file_path = new_file_dir + '/' + name

            Path(new_file_dir).mkdir(parents=True, exist_ok=True)
            with open(new_file_path, "w",
                      encoding='utf-8') as file:
                file.write(ConfigBuilder.__legacy_file_header() + content)

            pbar.update(1)

        pbar.close()

    @staticmethod
    def reset():
        ConfigBuilder.__templates = []
        ConfigBuilder.__commands = []
        ConfigBuilder.__servicegroups = []
        ConfigBuilder.__hostgroups = []
        ConfigBuilder.__ssh_templates = []
        ConfigBuilder.__time_periods = []
        ConfigBuilder.__downtimes = []
        ConfigBuilder.__os = []
        ConfigBuilder.__package_manager = []
        ConfigBuilder.__usergroups = []
        ConfigBuilder.__users = []
        ConfigBuilder.__notification_templates = []
        ConfigBuilder.__notifications = []
        ConfigBuilder.__notification_commands = []
        ConfigBuilder.__servers = []
        ConfigBuilder.__dependencies = []
        ConfigBuilder.__checks = []

    @staticmethod
    def get_config_as_string():
        ConfigBuilder.apply_utils()

        configs = [
            ConfigBuilder.__templates,
            ConfigBuilder.__commands,
            ConfigBuilder.__servicegroups,
            ConfigBuilder.__hostgroups,
            ConfigBuilder.__ssh_templates,
            ConfigBuilder.__time_periods,
            ConfigBuilder.__downtimes,
            ConfigBuilder.__os,
            ConfigBuilder.__package_manager,
            ConfigBuilder.__usergroups,
            ConfigBuilder.__users,
            ConfigBuilder.__notification_templates,
            ConfigBuilder.__notifications,
            ConfigBuilder.__notification_commands,
            ConfigBuilder.__servers,
            ConfigBuilder.__dependencies,
            ConfigBuilder.__checks,
        ]
        config_string = ConfigBuilder.__file_header()
        for config in configs:
            for conf in config:
                config_string += conf['instance'].get_config().replace('  ', '')

        custom_files = ConfigBuilder.__get_custom_files()
        config_string += ConfigBuilder.__legacy_file_header()
        for custom_file in custom_files:
            config_string += ConfigBuilder.__read_custom_file(str(custom_file))

        return config_string

    @staticmethod
    def __get_custom_files():

        if os.path.exists('legacy-config.d') \
                and os.path.isdir('legacy-config.d') \
                and os.access('legacy-config.d', os.R_OK):
            return Path('legacy-config.d').rglob('*.*')

        return []

    @staticmethod
    def __read_custom_file(filepath):
        with open(filepath, 'r') as file:
            return file.read()

    @staticmethod
    def get_hosts_with_hostgroup(group):
        servers_with_group = []
        for server in ConfigBuilder.__servers:
            if group in server['instance'].get_hostgroups_recursive():
                servers_with_group.append(server['instance'])

        return servers_with_group

    @staticmethod
    def get_checks_from_server(server):
        all_checks = server.get_checks()
        for template in server.get_templates():
            all_checks += ConfigBuilder.get_checks_from_server(template)

        return all_checks

    @staticmethod
    def get_instance(type):

        config = {
            'server': ConfigBuilder.__servers,
            'checks': ConfigBuilder.__checks,
            'templates': ConfigBuilder.__templates,
            'commands': ConfigBuilder.__commands,
            'servicegroups': ConfigBuilder.__servicegroups,
            'hostgroups': ConfigBuilder.__hostgroups,
            'usergroups': ConfigBuilder.__usergroups,
            'users': ConfigBuilder.__users,
            'sshtemplates': ConfigBuilder.__ssh_templates,
            'time_periods': ConfigBuilder.__time_periods,
            'notification_templates': ConfigBuilder.__notification_templates,
            'notification_commands': ConfigBuilder.__notification_commands,
            'notifications': ConfigBuilder.__notifications,
            'downtimes': ConfigBuilder.__downtimes,
            'os': ConfigBuilder.__os,
            'package_manager': ConfigBuilder.__package_manager,
            'zone': ConfigBuilder.__zones,
            'dependencies': ConfigBuilder.__dependencies
        }

        instances_config = config[type]
        instances = []

        for config in instances_config:
            instances.append(config['instance'])

        return instances

    @staticmethod
    def get_server(id):
        for server in ConfigBuilder.__servers:
            if server['id'] == id:
                return server['instance']

        return None

    @staticmethod
    def add_server(id, server):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_check(id):
            raise Exception('Server with id ' + id + ' already exists!')

        ConfigBuilder.__servers.append({'id': id, 'instance': server})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_check(id):

        for check in ConfigBuilder.__checks:
            if check['id'] == id:
                return check['instance']

        return None

    @staticmethod
    def add_check(id, check):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_check(id):
            raise Exception('Check with id ' + id + ' already exists!')

        ConfigBuilder.__checks.append({'id': id, 'instance': check})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_template(id):
        for template in ConfigBuilder.__templates:
            if template['id'] == id:
                return template['instance']

        return None

    @staticmethod
    def add_template(id, template):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_template(id):
            raise Exception('Template with id ' + id + ' already exists!')

        ConfigBuilder.__templates.append({'id': id, 'instance': template})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_command(id):
        for command in ConfigBuilder.__commands:
            if command['id'] == id:
                return command['instance']

        return None

    @staticmethod
    def add_command(id, command):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_command(id):
            raise Exception('Command with id ' + id + ' already exists!')

        ConfigBuilder.__commands.append({'id': id, 'instance': command})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_notification_command(id):
        for notification_command in ConfigBuilder.__notification_commands:
            if notification_command['id'] == id:
                return notification_command['instance']

        return None

    @staticmethod
    def add_notification_command(id, notification_command):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_notification_command(id):
            raise Exception('NotificationCommand with id ' + id + ' already exists!')

        ConfigBuilder.__notification_commands.append({'id': id, 'instance': notification_command})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_hostgroup(id):
        for group in ConfigBuilder.__hostgroups:
            if group['id'] == id:
                return group['instance']

        return None

    @staticmethod
    def add_hostgroup(id, group):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_hostgroup(id):
            raise Exception('Hostgroup with id ' + id + ' already exists!')

        ConfigBuilder.__hostgroups.append({'id': id, 'instance': group})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_usergroup(id):
        for group in ConfigBuilder.__usergroups:
            if group['id'] == id:
                return group['instance']

        return None

    @staticmethod
    def add_usergroup(id, group):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_usergroup(id):
            raise Exception('Usergroup with id ' + id + ' already exists!')

        ConfigBuilder.__usergroups.append({'id': id, 'instance': group})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_servicegroup(id):
        for group in ConfigBuilder.__servicegroups:
            if group['id'] == id:
                return group['instance']

        return None

    @staticmethod
    def add_servicegroup(id, group):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_servicegroup(id):
            raise Exception('Servicegroup with id ' + id + ' already exists!')

        ConfigBuilder.__servicegroups.append({'id': id, 'instance': group})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_ssh_template(id):
        for template in ConfigBuilder.__ssh_templates:
            if template['id'] == id:
                return template['instance']

        return None

    @staticmethod
    def add_ssh_template(id, group):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_ssh_template(id):
            raise Exception('SSH Template with id ' + id + ' already exists!')

        ConfigBuilder.__ssh_templates.append({'id': id, 'instance': group})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_time_period(id):
        for period in ConfigBuilder.__time_periods:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_time_period(id, period):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_time_period(id):
            raise Exception('Time Period with id ' + id + ' already exists!')

        ConfigBuilder.__time_periods.append({'id': id, 'instance': period})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_notification_template(id):
        for template in ConfigBuilder.__notification_templates:
            if template['id'] == id:
                return template['instance']

        return None

    @staticmethod
    def add_notification_template(id, period):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_notification_template(id):
            raise Exception('Notification Template with id ' + id + ' already exists!')

        ConfigBuilder.__notification_templates.append({'id': id, 'instance': period})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_notification(id):
        for notification in ConfigBuilder.__notifications:
            if notification['id'] == id:
                return notification['instance']

        return None

    @staticmethod
    def add_notification(id, notification):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_notification(id):
            raise Exception('Notification with id ' + id + ' already exists!')

        ConfigBuilder.__notifications.append({'id': id, 'instance': notification})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_user(id):
        for user in ConfigBuilder.__users:
            if user['id'] == id:
                return user['instance']

        return None

    @staticmethod
    def add_user(id, user):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_user(id):
            raise Exception('user with id ' + id + ' already exists!')

        ConfigBuilder.__users.append({'id': id, 'instance': user})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_downtime(id):
        for period in ConfigBuilder.__downtimes:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_downtime(id, period):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_downtime(id):
            raise Exception('Downtime with id ' + id + ' already exists!')

        ConfigBuilder.__downtimes.append({'id': id, 'instance': period})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_zone(id):
        for period in ConfigBuilder.__zones:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_zone(id, period):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_zone(id):
            raise Exception('Zone with id ' + id + ' already exists!')

        ConfigBuilder.__zones.append({'id': id, 'instance': period})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_os(id):
        for period in ConfigBuilder.__os:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_os(id, os):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_os(id):
            raise Exception('os with id ' + id + ' already exists!')

        ConfigBuilder.__os.append({'id': id, 'instance': os})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_package_manager(id):
        for period in ConfigBuilder.__package_manager:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_package_manager(id, package_manager):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_package_manager(id):
            raise Exception('package_manager with id ' + id + ' already exists!')

        ConfigBuilder.__package_manager.append({'id': id, 'instance': package_manager})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def get_dependency(id):
        for period in ConfigBuilder.__dependencies:
            if period['id'] == id:
                return period['instance']

        return None

    @staticmethod
    def add_dependency(id, dependency):
        if ConfigBuilder.__check_for_existence and None is not ConfigBuilder.get_dependency(id):
            raise Exception('dependency with id ' + id + ' already exists!')

        ConfigBuilder.__dependencies.append({'id': id, 'instance': dependency})
        ConfigBuilder.__pbar.update(1)

    @staticmethod
    def add_util_class(util_class):
        if util_class not in ConfigBuilder.__utils:
            ConfigBuilder.__utils.append(util_class)
